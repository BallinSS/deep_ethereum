---
title: "详解以太坊默克尔压缩前缀树-MPT"
menuTitle: "MPT"
date: 2019-11-17T21:50:18+08:00
weight: 300002
description: "详解以太坊默克尔压缩前缀树-MPT"
---

在以太坊中，一种经过改良的默克尔树非常关键，是以太坊数据安全与效率的保障，此树在以太坊中称之为 MPT（默克尔压缩前缀树）。
MPT 全称是 Merkle Patricia  Trie  也叫 Merkle Patricia Tree，是 Merkle Tree 和 Patricia Tree 的混合物。
Merkle Tree(默克尔树) 用于保证数据安全，Patricia Tree(基数树,也叫基数特里树或压缩前缀树) 用于提升树的读写效率。

{{% notice warning %}}
本文尚未完结，还需要讲解：树的增删改查、树的持久化和代码实现。
{{% /notice %}}

## 简述

以太坊不同于比特币的 UXTO 模型，在[账户模型]({{ref "part1/account.md"}})中，账户存在多个属性（余额、代码、存储尼尔），属性（状态）需要经常更新。因此需要一种数据结构来满足几点要求：

+ ①在执行插入、修改或者删除操作后能快速计算新的树根，而无需重新计算整个树。
+ ②即使攻击者故意构造非常深的树，它的深度也是有限的。否则，攻击者可以通过特意构建足够深的树使得每次树更新变得极慢，从而执行拒绝服务攻击。
+ ③树的根值仅取决于数据，而不取决于更新的顺序。已不同的顺序更新，甚至是从头重新计算树都不会改变树根值。

要求①是默克尔树特性，但要求②③则非默克尔树的优势。
对于要求②，可将数据 Key 进行一次哈希计算，得到确定长度的哈希值参与树的构建。而要求③则是引入位置确定的压缩前缀树并加以改进。


##  Trie  介绍

对部分开发者来说  Trie  这个术语可能比较陌生，而理解  Trie  的概念在本文中非常重要。因此，我先介绍  Trie  。

在计算机科学中， Trie ，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。
与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。
一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。
一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

Trie 这个术语来自于re Trie val。根据词源学， Trie 的发明者Edward Fredkin把它读作/ˈtriː/ "tree"。但是，其他作者把它读作/ˈtraɪ/ "try"。如图所示：

![以太坊技术与实现-图2019-11-17-22-25-43](https://learnblockchain.cn/static/以太坊技术与实现-图2019-11-17-22-25-43!de?width=300px)

在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。 Trie 可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示 Trie 的原理。

Trie 中的键通常是字符串，但也可以是其它的结构。 Trie 的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise  Trie 中的键是一串比特，可以用于表示整数或者内存地址。

> 上文摘自维基百科。

## 压缩前缀树(Patricia Tree)

在[压缩前缀树（基数树）](https://baike.baidu.com/item/基数树/22853708)中，键值是通过树到达相应值的实际路径值。
也就是说，从树的根节点开始，键中的每个字符会告诉您要遵循哪个子节点以获取相应的值，其中值存储在叶节点中，叶节点终止了穿过树的每个路径。假设键是包含 N 个字符的字母，则树中的每个节点最多可以有 N 个子级，并且树的最大深度是键的最大长度。

![以太坊技术与实现-图2019-11-17-23-24-32](https://learnblockchain.cn/static/以太坊技术与实现-图2019-11-17-23-24-32!de?width=300px)

虽然基数树使得以相同字符序列开头的键的值在树中靠得更近，但是它们可能效率很低。
例如，当你有一个超长键且没有其他键与之共享前缀时，即使路径上没有其他值，但你必须在树中移动（并存储）大量节点才能获得该值。

这种低效，如果直接使用在以太坊中会更加明显。因为参与树构建的 Key 是一个哈希值有 64 长（32 字节），则树的最长深度是 64。树中每个节点必须存储 32 字节，一个 Key 就需要至少 2KB 来存储，其中包含大量空白内容。

因此，在经常需要更新的以太坊状态树中，优化改进基数树，以提高效率、降低树的深度和减少 IO 次数，是必要的。

## 改进方案

为了解决基数树的效率问题，以太坊对 Patricia Tree 的最大改动是丰富了节点类型：


1. 空白节点
2. 分支节点：[0,1,...,16,value]
3. 叶子节点: [key,value]
4. 扩展节点: [key,value]

在 geth 中，四种类型的定义对应如下。

```go
//trie/node.go:35
type (
	fullNode struct { //分支节点
		Children [17]node
		flags    nodeFlag
	}
	shortNode struct { //叶子节点
		Key   []byte
		Val   node
		flags nodeFlag
	}
	hashNode  []byte //扩展节点
	valueNode []byte //值
)
var nilValueNode = valueNode(nil) //空白节点
```
fullNode 对应分支节点，shortNode 对应叶子节点，hashNode 对应扩展节点。并且将 value 也用一种值节点别名表示，以便理解程序算法。
当树为空时，则节点为空白节点。
分支节点是长度为 17 的列表。前 16 个元素对应键中可能存在的一个十六进制字符。
如果键[key,value]在对应的分支处结束，则在列表末尾存储 value 。
叶子节点是标准的节点类型，由 key 和 value 组成。
扩展节点与叶子节点类似，只是其值是某个节点的索引，用索引可在数据库中查找到节点数据。

不可避免地，在改进过程中以太坊增加了树操作的复杂性。下面讲解改进过程。

### 各类 Key

在改进过程中，为适应不同场景应用，以太坊定义了几种不同类型的 key 。

1. KEYBYTES ：数据的原始 key
2. Secure Key: 是 Sha(KEYBYTES) 结果，用于规避 key 深度攻击。
3. HEX Key: 将 Key 进行半字节拆解后的 key MPT 树路径和降低子节点水平宽度。
4. HP Key: Hex 前缀编码(hex prefix encoding)，在节点存持久化时，将对节点 key 进行压缩编码，并加入节点类型标签，以便从存储读取节点数据后可分辨节点类型。

![图：以太坊 MPT 中几类 Key](https://learnblockchain.cn/static/20191123215406.png!de?width=600px)

如上图，key 有特定的使用场景，并且支持逆向编码。

### 节点结构改进

当我们把一组数据（romane、romanus、romulus、rubens、ruber、rubicon、rubicunds）写入基数树中时，得到如下一颗基数树：

![](https://learnblockchain.cn/static/20191122001418.png!de?width=500px)

在上图的基数树中，持久化节点，有 13 次 IO。数据越多时，节点数越多，IO 次数越多。另外当树很深时，可能需要遍历到树的底部才能查询到数据。
面对此效率问题，以太坊在树中加入了一种名为**分支节点**(branch node) 的节点结构，将其子节点直接包含在自身的数据插槽中。

![](https://learnblockchain.cn/static/20191122235430.png!de)

这样可缩减深度和降低持久化 IO 数，特别是当插槽中均有子节点存在时，改进效果越明显。
下图是上方基数树在采用分支节点后的树节点布局：

![](https://learnblockchain.cn/static/20191122232439.png!de?width=400px&heigth=400px)

大圆圈均为分支节点，包含一个或多个子节点。其子节点可以是分支节点，也可以是叶子节点。可以看到节点数量并无改进。
设计分支节点的目的是降低 IO 和查询次数。持久化分支节点时，并不是将叶子节点分开持久化，而是将其存储在一块。
比如，数据 rubicon(6) 和 rubicunds(7) 是被一起持久化。在上图中，持久化 IO 只有 6 次，低于基数树的 12 次。

数据 Key 在进入 MPT 前已转换 Secure Key ， Secure Key 长度 32 字节（哈希值）。
一个字节的值范围是[0 - 255]， 如果在分支节点中使用 256 个插槽，空间开销非常高，造成浪费。即使是空插槽在持久化时也需要占用空间。同时超大容量的插槽，也会可能使得持久化数据过大，可能会造成读取持久化数据时占用过多内存。
如果将 Key 的每个字节拆成两个半字节(高四位和低四位)，每个字节值范围被缩小到 [0-15] 内(4bits)。这样，分支节点只需要 16 个插槽来存放子节点。

> 高四位和低四位，这里的“位”是针对二进制来说的。比如数字 250 的二进制数为 11111010，则高四位是左边的 1111，低四位是右边的 1010。

![](https://learnblockchain.cn/static/20191123004006.png!de?width=500px)

上图中 0 - f 插槽索引是半字节值，也是 Key 路径的一部分。虽然一定程度上增加了树高，但降低了分支节点的存储大小，也保证了一定的分支节点合并量。

持久化时是将如果节点不是叶子节点，那么需要将节点内容序列化存储，并将存储的索引作为 Value 进行参与树的持久化，这种新型的节点称之为扩展节点。但当读取节点时，这难以区分是叶子节点还是扩展节点。
因此，在节点持久化时，将存储键中加入了节点类型前缀，即 Hex 前缀编码。当读取的节点是扩展节点时还需要进一步根据索引读取和反序列化节点内容。

## 参考资料

1. https://github.com/ethereum/wiki/wiki/Patricia-Tree
2. https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D
3. https://ethfans.org/toya/articles/588
4. https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/
5. https://arxiv.org/pdf/1909.11590.pdf