---
title: "详解以太坊默克尔压缩前缀树-MPT"
menuTitle: "MPT"
date: 2019-11-17T21:50:18+08:00
weight: 300002
description: "详解以太坊默克尔压缩前缀树-MPT"
---

在以太坊中，一种经过改良的默克尔树非常关键，是以太坊数据安全与效率的保障，此树在以太坊中称之为 MPT（默克尔压缩前缀树）。
MPT 全称是 Merkle Patricia  Trie  也叫 Merkle Patricia Tree，是 Merkle Tree 和 Patricia Tree 的混合物。
Merkle Tree(默克尔树) 用于保证数据安全，Patricia Tree(基数树,也叫基数特里树或压缩前缀树) 用于提升树的读写效率。

{{% notice warning %}}
本文尚未完结，待写树的持久化和代码实现。
{{% /notice %}}

## 简述

以太坊不同于比特币的 UXTO 模型，在[账户模型]({{ref "part1/account.md"}})中，账户存在多个属性（余额、代码、存储信息），属性（状态）需要经常更新。因此需要一种数据结构来满足几点要求：

+ ①在执行插入、修改或者删除操作后能快速计算新的树根，而无需重新计算整个树。
+ ②即使攻击者故意构造非常深的树，它的深度也是有限的。否则，攻击者可以通过特意构建足够深的树使得每次树更新变得极慢，从而执行拒绝服务攻击。
+ ③树的根值仅取决于数据，而不取决于更新的顺序。以不同的顺序更新，甚至是从头重新计算树都不会改变树的根值。

要求①是默克尔树特性，但要求②③则非默克尔树的优势。
对于要求②，可将数据 Key 进行一次哈希计算，得到确定长度的哈希值参与树的构建。而要求③则是引入位置确定的压缩前缀树并加以改进。


##  Trie  介绍

对部分开发者来说  Trie  这个术语可能比较陌生，而理解  Trie  的概念在本文中非常重要。因此，我先介绍  Trie  。

在计算机科学中， Trie ，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。
与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。
一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。
一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

Trie 这个术语来自于re Trie val。根据词源学， Trie 的发明者Edward Fredkin把它读作/ˈtriː/ "tree"。但是，其他作者把它读作/ˈtraɪ/ "try"。如图所示：

![以太坊技术与实现-图2019-11-17-22-25-43](https://learnblockchain.cn/static/以太坊技术与实现-图2019-11-17-22-25-43!de?width=300px)

在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。 Trie 可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示 Trie 的原理。

Trie 中的键通常是字符串，但也可以是其它的结构。 Trie 的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise  Trie 中的键是一串比特，可以用于表示整数或者内存地址。

> 上文摘自维基百科。

## 压缩前缀树(Patricia Tree)

在[压缩前缀树（基数树）](https://baike.baidu.com/item/基数树/22853708)中，键值是通过树到达相应值的实际路径值。
也就是说，从树的根节点开始，键中的每个字符会告诉您要遵循哪个子节点以获取相应的值，其中值存储在叶节点中，叶节点终止了穿过树的每个路径。假设键是包含 N 个字符的字母，则树中的每个节点最多可以有 N 个子级，并且树的最大深度是键的最大长度。

![以太坊技术与实现-图2019-11-17-23-24-32](https://learnblockchain.cn/static/以太坊技术与实现-图2019-11-17-23-24-32!de?width=300px)

虽然基数树使得以相同字符序列开头的键的值在树中靠得更近，但是它们可能效率很低。
例如，当你有一个超长键且没有其他键与之共享前缀时，即使路径上没有其他值，但你必须在树中移动（并存储）大量节点才能获得该值。
这种低效在以太坊中会更加明显，因为参与树构建的 Key 是一个哈希值有 64 长（32 字节），则树的最长深度是 64。树中每个节点必须存储 32 字节，一个 Key 就需要至少 2KB 来存储，其中包含大量空白内容。
因此，在经常需要更新的以太坊状态树中，优化改进基数树，以提高效率、降低树的深度和减少 IO 次数，是必要的。

## 改进方案

为了解决基数树的效率问题，以太坊对基数树的最大改动是丰富了节点类型：


1. 空白节点 NULL
2. 分支节点 branch [0,1,...,16,value]
3. 叶子节点 leaf : [key,value]
4. 扩展节点 extension: [key,value]

在 geth 中，四种类型的定义对应如下。

```go
//trie/node.go:35
type (
	fullNode struct { //分支节点
		Children [17]node
		flags    nodeFlag
	}
	shortNode struct { //短节点
		Key   []byte
		Val   node
		flags nodeFlag
	}
	hashNode  []byte //扩展节点
	valueNode []byte //数据节点,但他的值就是实际的数据值
)
var nilValueNode = valueNode(nil) //空白节点
```
fullNode 对应分支节点，hashNode 对应扩展节点。当树为空时，则节点为空白节点。
shortNode 和 valueNode 均属于叶子节点，shortNode 的值是 node ,而 valueNode 的值就是数据本身，代表外部写入的原始数据。
分支节点是长度为 17 的列表。前 16 个元素对应键中可能存在的一个十六进制字符。
如果键[key,value]在对应的分支处结束，则在列表末尾存储 value 。
叶子节点是标准的节点类型，由 key 和 value 组成。
扩展节点与叶子节点类似，只是其值是某个节点的索引，用索引可在数据库中查找到节点数据。

不可避免地，在改进过程中以太坊增加了树操作的复杂性。

### 各类 Key

在改进过程中，为适应不同场景应用，以太坊定义了几种不同类型的 key 。

1. KEYBYTES ：数据的原始 key
2. Secure Key: 是 Sha(KEYBYTES) 结果，用于规避 key 深度攻击，长度固定为 32 字节。
3. HEX Key: 将 Key 进行半字节拆解后的 key ，用于 MPT 的树路径中和降低子节点水平宽度。
4. HP Key: Hex 前缀编码(hex prefix encoding)，在节点存持久化时，将对节点 key 进行压缩编码，并加入节点类型标签，以便从存储读取节点数据后可分辨节点类型。


下图是 key 有特定的使用场景，基本支持逆向编码。在下面的讲解中 Key 在不同语义下特指的类型有所不同。
![图：以太坊 MPT 中几类 Key](https://learnblockchain.cn/static/20191123215406.png!de?width=600px)


### 节点结构改进

当我们把一组数据（romane、romanus、romulus、rubens、ruber、rubicon、rubicunds）写入基数树中时，得到如下一颗基数树：

![](https://learnblockchain.cn/static/20191122001418.png!de?width=500px)

在上图的基数树中，持久化节点，有 13 次 IO。数据越多时，节点数越多，IO 次数越多。另外当树很深时，可能需要遍历到树的底部才能查询到数据。
面对此效率问题，以太坊在树中加入了一种名为**分支节点**(branch node) 的节点结构，将其子节点直接包含在自身的数据插槽中。

![](https://learnblockchain.cn/static/20191122235430.png!de?width=500px)

这样可缩减树深度和减少IO次数，特别是当插槽中均有子节点存在时，改进效果越明显。
下图是上方基数树在采用分支节点后的树节点逻辑布局：

![](https://learnblockchain.cn/static/20191122232439.png!de?width=400px&heigth=400px)

从图中可以看出节点数量并无改进，仅仅是改变了节点的存放位置，节点的分布变得紧凑。图中大黑圆圈均为分支节点，它包含一个或多个子节点，
这降低了 IO 和查询次数，在上图中，持久化 IO 只有 6 次，低于基数树的 12 次。

这是因为在持久化分支节点时，并不是将叶子节点分开持久化，而是将其存储在一块。并将持久化内容的哈希值作为一个新节点来参与树的进一步持久化，这种新型的节点称之为扩展节点。比如，数据 rubicon(6) 和 rubicunds(7) 是被一起持久化，在查询数据 rubicon 时，将一次性将 rubicon 和 rubicunds 数据节点都加载到内存汇总。

但当读取节点时，这难以区分是叶子节点还是扩展节点。因此，在节点持久化时，将存储键中加入了节点类型前缀，即 Hex 前缀编码。当读取的节点是扩展节点时还需要进一步根据索引读取和反序列化节点内容。

另外，数据 Key 在进入 MPT 前已转换 Secure Key。
因为，一个字节的值范围是[0 - 255]， 如果在分支节点中使用 256 个插槽，空间开销非常高，造成浪费，毕竟空插槽在持久化时也需要占用空间。同时超大容量的插槽，也会可能使得持久化数据过大，可能会造成读取持久化数据时占用过多内存。
如果将 Key 的每个字节拆成两个半字节(高四位和低四位)，每个字节值范围被缩小到 [0-15] 内(4bits)。这样，分支节点只需要 16 个插槽来存放子节点。

> 高四位和低四位，这里的“位”是针对二进制来说的。比如数字 250 的二进制数为 11111010，则高四位是左边的 1111，低四位是右边的 1010。

![](https://learnblockchain.cn/static/20191123004006.png!de?width=500px)

上图中 0 - f 插槽索引是半字节值，也是 Key 路径的一部分。虽然一定程度上增加了树高，但降低了分支节点的存储大小，也保证了一定的分支节点合并量。

## 树的增删改查

上面已介绍树的改进内容，下面我们来讲解经过改进后，树的增删改查将有哪些不一样。在讲解前需要你掌握几个内含的规则和概念：

1. MPT 是一颗逻辑树，并不一一对应物理树（存储）。
2. 在 MPT 中必将在叶子节点处存放在 Key 对应的 Value，数据节点必然是在树的子叶中。
3. 在 MPT 中，到达节点的树路径 Path 和节点中记录的 Key 一起构成了节点的完整 Key。
4. 树路径称也可之为 Key 前缀。
4. 分支节点的插槽 Index 就是树路径的一部分。

### 查询数据

即使在修改某项数据时，也会涉及到查询，因此我先讲讲 MPT 树的查询逻辑。
在树中查找数据，需要考虑性能，省时和低 IO 是关键。
因为数据项 [Key,Value] 的 Key 是确定的，那么数据在 MPT 中的树路径也是确定的。
因此，达到数据项的路径是唯一的，是效率最高的最短路径查找。

下图是以太坊从 MPT 中查询查找某 Key 对应数据的流程图。

![以太坊从 MPT 中查询查找某 Key 对应数据的流程图](http://learnblockchain.cn/static/20191127162304.png!de?width=600px)

图中流程中，有几点需要稍微说明：

1. 查找时依赖节点的类型，不同类型的节点所包含的值属性不同。
1. 要找的数据虽然并不一定对应一个存储，但在 MPT 的逻辑树中数据是树的叶子节点，用 valueNode 表示。
1. 在分支节点中继续向下查找时，分支节点的子节点插槽也属于路径的一部分，占用一个字节。根据 pos= key[0] 便可以确认在插槽 pos 中继续查找。
1. 短节点 shortNode [key,value] 中只有在 数据 key 是 node.key 的前缀时，才能说明数据项属于 node 子树的一部分，可以继续查找。
1. 当节点是扩展节点类型时，node 本身就是 bytes，是节点数据被存储到 KV 数据库时所用的键，根据此键可以从数据库中读取节点原始数据。加载节点数据到内存后，可以继续判断节点类型。


### 插入数据

插入数据包含新数据加入和旧数据修改。下图是往 MPT 中插入数据流程。

![以太坊技术与实现-图-往 MPT 中插入数据](http://learnblockchain.cn/static/20191127163002.png!de?width=)

首先，插入空节点是无意义的，反而会使树变得臃肿。
因此，当数据为空时，需从树中删除该数据节点。
否则需要根据数据节点的路径从树根开始查找到数据节点所在位置来更新节点。在查找时根据路径中节点的类型不同，需要不同的解析方式。

1. 判断当前节点的类型，如果是扩展节点，则需要先从数据库中读取节点原始数据。还原成一颗子树后，继续执行插入到此子树中。
2. 如果是分支节点，那么只需要确认子节点插槽位置，便可以将子节点作为一颗子树继续下探尝试更新。
3. 如果是短节点，则需匹配相同前缀。如果前缀刚好等于原节点key，则说明需要将原节点的 value 进行更新。
否则，说明此路径处需要分叉才能容纳这个两个节点。分叉时，是构建新的分支节点，新节点的 key 为相同前缀部分，将原节点下移到新节点下对应的子节点插槽中。
数据节点则也存放在新节点对应的插槽中。
4. 当到达叶子节点时，数据节点的 Key 是不存在的，节点本身即是数据。如果节点不含数据，则说明插入的节点是第一次出现，属于新增。在树中加入此数据节点即可。
   如果存在数据，则说明属于更新旧数据，覆盖即可。

插入数据的过程，是深度递归遍历方式。先深度查找，抵达数据应处位置，再从下向上依次更新此路径上的节点。
虽然只更新了路径中的相关节点，但这毕竟涉及多个节点的更新。从这一点上看，MPT 性能并不出色。

![以太坊技术与实现-图-以太坊 MPT 树操作时的递归](http://learnblockchain.cn/static/20191127163603.png!de?width=300px)

### 删除数据

从 MPT 中删除数据节点，这比插入数据更加复杂。从树中删除一个节点是容易的，但在 MPT 中删除节点后需要根据前面的改进方案调整结构。
比如，原本是一个分支节点下有两个子节点，现在删除一个子节点后，只有一个子节点的分支节点的存储是无意义的，需要移除并将剩余的子节点上移。
下图是 MPT 中删除数据的流程图。

![以太坊技术与实现-图- MPT中删除数据的流程图](http://learnblockchain.cn/static/20191127163805.png!de?width=600px)
同样，删除数据也是深度递归遍历。先深度查找，抵达数据应处位置，再从下向上依次更新此路径上的节点。
在删除过程中，主要是对删除后节点的调整。有两个原则：

1. 分支节点至少要有两个子节点，如果只有一个子节点或者没有则需要调整。
2. shortNode 的 value 是 shortNode 时可合并。

删除数据也涉及路径上节点的更新，图中的绿色虚线是表示递归删除节点。

### 树更新实例

下面，我演示依次将一组数据 romane、romanus、romulus、rubens、ruber、rubicon、rubicunds 插入到 MPT 中时的树结构的变化情况。

首先依次写入：romane、romanus、romulus 后树的变化如下：

![以太坊技术与实现-图-20191127165135.png](http://learnblockchain.cn/static/20191127165135.png!de?width=600px)

图中的每一个圆圈均代表一个节点，只是节点的类型不同。需要注意的是，图中的红色字部分，实际是一个短节点（shortNode）。
比如，红色的“roman“ 短节点的 key 为 roman, value 是分支节点。继续写入 rubens、ruber、rubicon 的变化过程如下：

![以太坊技术与实现-图-20191127165900.png](http://learnblockchain.cn/static/20191127165900.png!de?width=800px)

最后，写入最后一个数据项 rubicunds 后可得到最终的 MPT 树结构：

![以太坊技术与实现-图-20191127170214.png](http://learnblockchain.cn/static/20191127170214.png!de?width=400px)

{{% notice warning %}}
注意，本过程演示中，为降低复杂度，省去了 key 的 Secure 和 Hex 过程。
{{% /notice %}}

### MPT数操作总结

即使以太坊有大量改进基数树，形成 MPT。但还是并没有解决树节点更新时的蝴蝶效应问题。
在 MPT 中树的最大深度是 64，当树充分大时，为更新一个数据节点而需要连带更新的节点也非常多。
这使得以太坊的数据更新是昂贵的。大量的变动也会使得每产生一个新区块，持久化数据后。
有大量的存储不再属于最新状态的一部分，即以太坊的数据增量更新的体量依旧很大。

如果要满足以太坊 2.0 的性能要求，继续改进 MPT 是不可忽略的。

## 参考资料

1. https://github.com/ethereum/wiki/wiki/Patricia-Tree
2. https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D
3. https://ethfans.org/toya/articles/588
4. https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/
5. https://arxiv.org/pdf/1909.11590.pdf